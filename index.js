// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIPAL NEURA-KNIGHTS V1.0
// Automated daily battle & quest bot for NeuraKnights
// Generated by Sipal Airdrop Community
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import axios from 'axios';
import chalk from 'chalk';
import fs from 'fs/promises';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { SocksProxyAgent } from 'socks-proxy-agent';
import Table from 'cli-table3';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Game API
const API_BASE = 'https://neura-knights-api-prod.anomalygames.ai/api';
const NOVALINK_API = 'https://prod-api.novalinkapp.com/api/v1';

// Captcha
let CAPTCHA_API_KEY = '';
const TURNSTILE_SITEKEY = '0x4AAAAAAA_yJEOW8snxwG5_';
const SITE_URL = 'https://www.neuraknights.gg';

// Battle
const MAX_ROUNDS = 50;
const CARD_PLAY_DELAY_MS = 300;
const ROUND_POLL_DELAY_MS = 500;
const BATTLE_TIMEOUT_MS = 180000;
const BANNED_CARD_TYPES = ['necklace'];
const MAX_LOSSES_PER_MAP = 3;
const MAX_TOTAL_BATTLES = 30;

// Scheduler (WIB = Asia/Jakarta)
const SCHEDULED_HOUR = 7;
const SCHEDULED_MINUTE = 30;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL STATE & DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const state = {
  accounts: [],
  logs: [],
  isRunning: true
};

const LOG_LIMIT = 10;

function formatDuration(ms) {
  if (ms < 0) ms = 0;
  const h = Math.floor(ms / 3600000);
  const m = Math.floor((ms % 3600000) / 60000);
  const s = Math.floor((ms % 60000) / 1000);
  return `${h}h ${m}m ${s}s`;
}

function logToState(msg) {
  const timestamp = new Date().toLocaleTimeString();
  const line = `${chalk.gray(`[${timestamp}]`)} ${msg}`;
  state.logs.push(line);
  if (state.logs.length > LOG_LIMIT) state.logs.shift();
  // console.log(line); // REMOVED: Breaks the dashboard layout if printed directly.
  renderTable(); // Update the UI with the new log line immediately.
}

function renderTable() {
  console.clear();

  // Banner
  console.log(chalk.blue(`
               / \\
              /   \\
             |  |  |
             |  |  |
              \\  \\
             |  |  |
             |  |  |
              \\   /
               \\ /
  `));
  console.log(chalk.bold.cyan('    ======SIPAL AIRDROP======'));
  console.log(chalk.bold.cyan('  =====SIPAL NEURA-KNIGHTS V1.0====='));
  console.log('');

  // Account Table
  const table = new Table({
    head: ['Account', 'IP', 'Status', 'Last Run', 'Next Run', 'Activity'],
    colWidths: [12, 18, 14, 12, 12, 28],
    style: { head: ['cyan'], border: ['grey'] }
  });

  state.accounts.forEach(acc => {
    let statusText = acc.status || '-';
    if (acc.status === 'SUCCESS') statusText = chalk.green(acc.status);
    else if (acc.status === 'FAILED') statusText = chalk.red(acc.status);
    else if (acc.status === 'PROCESSING') statusText = chalk.yellow(acc.status);
    else if (acc.status === 'WAITING') statusText = chalk.blue(acc.status);
    else if (acc.status === 'EXPIRED') statusText = chalk.redBright(acc.status);

    let nextRunStr = '-';
    if (acc.nextRun) {
      const diff = acc.nextRun - Date.now();
      if (diff > 0) nextRunStr = formatDuration(diff);
      else nextRunStr = 'Ready';
    }

    let lastRunStr = '-';
    if (acc.lastRun) {
      lastRunStr = new Date(acc.lastRun).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    table.push([
      `Account ${acc.index}`,
      chalk.magenta(acc.ip || '-'),
      statusText,
      lastRunStr,
      nextRunStr,
      chalk.gray((acc.info || '-').substring(0, 26))
    ]);
  });

  console.log(table.toString());

  // Logs Area
  console.log(chalk.yellow(' EXECUTION LOGS:'));
  state.logs.forEach(log => console.log(log));
  console.log(chalk.bold.cyan('='.repeat(96)));
}

function printSessionSummary(results) {
  logToState(`${chalk.bold.cyan('--- SESSION SUMMARY ---')}`);

  const table = new Table({
    head: ['Account', 'Gold', 'Status', 'Tasks', 'Battles'],
    style: { head: ['cyan'], border: ['grey'] },
    colWidths: [12, 15, 12, 15, 15]
  });

  results.forEach((res, index) => {
    const status = res.status === 'Success' ? chalk.green('Success') : chalk.red('Failed');
    const tasks = `${res.tasks?.completed || 0}/${res.tasks?.total || 0}`;
    const battles = `${res.battles?.won || 0}/${res.battles?.executed || 0}`;
    table.push([`Acc ${index + 1}`, res.points || '0', status, tasks, battles]);
  });

  console.log(table.toString());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNIFIED LOGGER
// Handles both patterns:
//   logger.info('msg', 'CONTEXT')           (battle system)
//   logger.info('msg', { context, emoji })   (main system)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const logger = {
  info: (msg, ctxOrOpts = {}) => {
    let context = '', emoji = 'â„¹ï¸  ';
    if (typeof ctxOrOpts === 'string') { context = ctxOrOpts; }
    else { context = ctxOrOpts.context || ''; emoji = ctxOrOpts.emoji || emoji; }
    const c = context ? `[${context}]` : '';
    logToState(`${emoji}${chalk.cyan(c.padEnd(12))} ${msg}`);
  },
  success: (msg, ctxOrOpts = {}) => {
    let context = '', emoji = 'âœ… ';
    if (typeof ctxOrOpts === 'string') { context = ctxOrOpts; }
    else { context = ctxOrOpts.context || ''; emoji = ctxOrOpts.emoji || emoji; }
    const c = context ? `[${context}]` : '';
    logToState(`${emoji}${chalk.cyan(c.padEnd(12))} ${chalk.green(msg)}`);
  },
  warn: (msg, ctxOrOpts = {}) => {
    let context = '', emoji = 'âš ï¸  ';
    if (typeof ctxOrOpts === 'string') { context = ctxOrOpts; }
    else { context = ctxOrOpts.context || ''; emoji = ctxOrOpts.emoji || emoji; }
    const c = context ? `[${context}]` : '';
    logToState(`${emoji}${chalk.cyan(c.padEnd(12))} ${chalk.yellow(msg)}`);
  },
  error: (msg, ctxOrOpts = {}) => {
    let context = '', emoji = 'âŒ ';
    if (typeof ctxOrOpts === 'string') { context = ctxOrOpts; }
    else { context = ctxOrOpts.context || ''; emoji = ctxOrOpts.emoji || emoji; }
    const c = context ? `[${context}]` : '';
    logToState(`${emoji}${chalk.cyan(c.padEnd(12))} ${chalk.red(msg)}`);
  },
  battle: (msg, ctxOrOpts = {}) => {
    let context = '';
    if (typeof ctxOrOpts === 'string') { context = ctxOrOpts; }
    else { context = ctxOrOpts.context || ''; }
    const c = context ? `[${context}]` : '';
    logToState(`âš”ï¸  ${chalk.cyan(c.padEnd(12))} ${chalk.magenta(msg)}`);
  },
  debug: (msg, ctxOrOpts = {}) => {
    let context = '';
    if (typeof ctxOrOpts === 'string') { context = ctxOrOpts; }
    else { context = ctxOrOpts.context || ''; }
    const c = context ? `[${context}]` : '';
    logToState(`ğŸ” ${chalk.cyan(c.padEnd(12))} ${chalk.cyan(msg)}`);
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function delay(seconds) {
  return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

function delayMs(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function parseTokenExpiry(token) {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
    if (payload.exp) {
      const expiryDate = new Date(payload.exp * 1000);
      const now = new Date();
      const diffMs = expiryDate - now;
      if (diffMs <= 0) {
        return { expired: true, date: expiryDate, remaining: 'EXPIRED' };
      }
      const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const mins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      let remaining = '';
      if (days > 0) remaining += `${days}d `;
      if (hours > 0) remaining += `${hours}h `;
      if (days === 0 && mins > 0) remaining += `${mins}m`;
      return { expired: false, date: expiryDate, remaining: remaining.trim() };
    }
    return null;
  } catch (e) {
    return null;
  }
}

function getNextScheduledTime(hour = 7, minute = 30) {
  const now = new Date();
  const next = new Date(now);
  next.setHours(hour, minute, 0, 0);
  if (now >= next) {
    next.setDate(next.getDate() + 1);
  }
  return next;
}

async function waitUntilScheduledTime(hour = 7, minute = 30) {
  const nextRun = getNextScheduledTime(hour, minute);
  const nextRunMs = nextRun.getTime();

  // Update all accounts with next run time
  for (const acc of state.accounts) {
    acc.nextRun = nextRunMs;
  }

  const targetStr = nextRun.toLocaleString('id-ID', {
    timeZone: 'Asia/Jakarta',
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit'
  });
  logger.info(`Next cycle scheduled at: ${targetStr} WIB`);

  return new Promise((resolve) => {
    const waitMs = nextRunMs - Date.now();
    if (waitMs <= 0) { resolve(); return; }

    // Periodic dashboard refresh during wait
    const refreshId = setInterval(() => renderTable(), 10000);

    // Hourly heartbeat log
    const hourlyId = setInterval(() => {
      const remaining = nextRunMs - Date.now();
      if (remaining > 0) {
        logger.info(`Waiting... ${formatDuration(remaining)} until next cycle`);
      }
    }, 3600000);

    setTimeout(() => {
      clearInterval(refreshId);
      clearInterval(hourlyId);
      logger.success('Starting new cycle...');
      resolve();
    }, waitMs);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTTP HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Firefox/102.0'
];

function getRandomUserAgent() {
  return userAgents[Math.floor(Math.random() * userAgents.length)];
}

function getAxiosConfig(proxy, token = null, bearer = false, additionalHeaders = {}) {
  const headers = {
    'accept': 'application/json, text/plain, */*',
    'accept-encoding': 'gzip, deflate, br',
    'accept-language': 'en-GB,en-US;q=0.9,en;q=0.8,id;q=0.7,fr;q=0.6,ru;q=0.5,zh-CN;q=0.4,zh;q=0.3',
    'cache-control': 'no-cache',
    'content-type': 'application/json',
    'origin': 'https://www.neuraknights.gg',
    'pragma': 'no-cache',
    'priority': 'u=1, i',
    'referer': 'https://www.neuraknights.gg/',
    'sec-ch-ua': '"Not;A=Brand";v="99", "Opera";v="123", "Chromium";v="139"',
    'sec-ch-ua-mobile': '?0',
    'sec-ch-ua-platform': '"Windows"',
    'sec-fetch-dest': 'empty',
    'sec-fetch-mode': 'cors',
    'sec-fetch-site': 'cross-site',
    'user-agent': getRandomUserAgent(),
    ...additionalHeaders
  };
  if (token) {
    headers['authorization'] = bearer ? `Bearer ${token}` : `${token}`;
  }
  const config = {
    headers,
    timeout: 60000
  };
  if (proxy) {
    config.httpsAgent = newAgent(proxy);
    config.proxy = false;
  }
  return config;
}

function newAgent(proxy) {
  if (proxy.startsWith('http://') || proxy.startsWith('https://')) {
    return new HttpsProxyAgent(proxy);
  } else if (proxy.startsWith('socks4://') || proxy.startsWith('socks5://')) {
    return new SocksProxyAgent(proxy);
  } else {
    logger.warn(`Unsupported proxy: ${proxy}`);
    return null;
  }
}

async function requestWithRetry(method, url, payload = null, config = {}, retries = 3, backoff = 2000, context) {
  for (let i = 0; i < retries; i++) {
    try {
      let response;
      if (method.toLowerCase() === 'get') {
        response = await axios.get(url, config);
      } else if (method.toLowerCase() === 'post') {
        response = await axios.post(url, payload, config);
      } else {
        throw new Error(`Method ${method} not supported`);
      }
      return response;
    } catch (error) {
      if (error.response && error.response.status >= 500 && i < retries - 1) {
        logger.warn(`Retrying ${method.toUpperCase()} ${url} (${i + 1}/${retries}) due to server error`, { context });
        await delay(backoff / 1000);
        backoff *= 1.5;
        continue;
      }
      if (i < retries - 1) {
        logger.warn(`Retrying ${method.toUpperCase()} ${url} (${i + 1}/${retries})`, { context });
        await delay(backoff / 1000);
        backoff *= 1.5;
        continue;
      }
      throw error;
    }
  }
}

async function readAccounts() {
  try {
    const data = await fs.readFile('accounts.json', 'utf-8');
    const config = JSON.parse(data);

    // Handle both old array format (legacy) and new object format
    if (Array.isArray(config)) {
      logger.info(`Loaded ${config.length} accounts (LEGACY FORMAT)`, { context: 'CONFIG' });
      return config;
    } else {
      if (config.captcha_api_key) {
        CAPTCHA_API_KEY = config.captcha_api_key;
        logger.info(`Loaded Captcha API Key: ${CAPTCHA_API_KEY.slice(0, 4)}...${CAPTCHA_API_KEY.slice(-4)}`, { context: 'CONFIG' });
      }
      const accounts = config.accounts || [];
      logger.info(`Loaded ${accounts.length} accounts`, { context: 'CONFIG' });
      return accounts;
    }
  } catch (error) {
    logger.error(`Failed to read accounts.json: ${error.message}`, { context: 'CONFIG' });
    return [];
  }
}

async function getPublicIP(proxy, context) {
  try {
    const config = getAxiosConfig(proxy);
    const response = await requestWithRetry('get', 'https://api.ipify.org?format=json', null, config, 3, 2000, context);
    return response.data.ip || 'Unknown';
  } catch (error) {
    logger.error(`Failed to get IP: ${error.message}`, { context });
    return 'Error';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchProfile(token, proxy, context) {
  const url = 'https://prod-api.novalinkapp.com/api/v1/profile';
  try {
    const config = getAxiosConfig(proxy, token, true);
    const response = await requestWithRetry('get', url, null, config, 3, 2000, context);
    if (response.data.success) {
      const email = response.data.data.authentications[0]?.email || 'N/A';
      const novaLinkUserId = response.data.data.novaLinkUserId || null;
      return { email, novaLinkUserId };
    } else {
      throw new Error('Failed to fetch profile');
    }
  } catch (error) {
    logger.error(`Failed to fetch profile: ${error.message}`, { context });
    return { email: 'N/A', novaLinkUserId: null };
  }
}

async function fetchUserGold(stateData, context) {
  if (!stateData) return '0';
  const gold = stateData.gold || stateData.coins || stateData.currency || stateData.total_gold || 0;
  return gold.toString();
}

async function fetchActiveTasks(token, proxy, context) {
  const url = 'https://neura-knights-api-prod.anomalygames.ai/api/quests';
  try {
    const config = getAxiosConfig(proxy, token);
    const response = await requestWithRetry('get', url, null, config, 3, 2000, context);
    if (response.data.success) {
      return response.data.data;
    } else {
      throw new Error('Failed to fetch tasks');
    }
  } catch (error) {
    logger.error(`Failed to fetch active tasks: ${error.message}`, { context });
    return [];
  }
}

async function completeTask(token, taskId, taskTitle, proxy, context) {
  const taskContext = `${context}|T${taskId.toString().slice(-6)}`;
  const url = 'https://neura-knights-api-prod.anomalygames.ai/api/quests';
  const payload = { quest_id: taskId };
  const config = getAxiosConfig(proxy, token);
  config.validateStatus = (status) => status >= 200 && status < 500;
  try {
    const response = await requestWithRetry('post', url, payload, config, 3, 2000, taskContext);
    if (response.data.success) {
      logger.success(`Completed: ${taskTitle}`, { context: taskContext });
      return { success: true, message: `Completed: ${taskTitle}` };
    } else {
      logger.warn(`Failed to complete ${taskTitle}`, { context: taskContext });
      return { success: false, message: `Failed to complete ${taskTitle}` };
    }
  } catch (error) {
    logger.error(`Failed to complete ${taskTitle}: ${error.message}`, { context: taskContext });
    return { success: false, message: `Failed: ${error.message}` };
  }
}

async function fetchState(novaLinkUserId, token, proxy, context) {
  const url = `https://neura-knights-api-prod.anomalygames.ai/api/state?novalink_user_id=${novaLinkUserId}`;
  try {
    const config = getAxiosConfig(proxy, token, true);
    const response = await requestWithRetry('get', url, null, config, 3, 2000, context);
    if (response.data.success) {
      return response.data.data;
    } else {
      throw new Error('Failed to fetch state');
    }
  } catch (error) {
    logger.error(`Failed to fetch state: ${error.message}`, { context });
    return null;
  }
}

async function claimPackage(novaLinkUserId, token, proxy, context) {
  const url = `https://neura-knights-api-prod.anomalygames.ai/api/package/claim?novalink_user_id=${novaLinkUserId}`;
  const payload = { novalink_user_id: novaLinkUserId };
  const config = getAxiosConfig(proxy, token, true);
  config.validateStatus = (status) => status >= 200 && status < 500;
  try {
    const response = await requestWithRetry('post', url, payload, config, 3, 2000, context);
    if (response.data.success) {
      logger.success('Packs claimed successfully', { context });
      return { success: true };
    } else {
      logger.warn('Failed to claim packs', { context });
      return { success: false };
    }
  } catch (error) {
    logger.error(`Failed to claim packs: ${error.message}`, { context });
    return { success: false };
  }
}

async function fetchUserPackages(novaLinkUserId, token, proxy, context) {
  const url = `https://neura-knights-api-prod.anomalygames.ai/api/inventory/packages?novalink_user_id=${novaLinkUserId}`;
  try {
    const config = getAxiosConfig(proxy, token, true);
    const response = await requestWithRetry('get', url, null, config, 3, 2000, context);
    if (response.data.success) {
      return response.data.data || [];
    } else {
      throw new Error('Failed to fetch packages');
    }
  } catch (error) {
    logger.error(`Failed to fetch packages: ${error.message}`, { context });
    return [];
  }
}

async function openPack(novaLinkUserId, token, packageType, packageCollection, proxy, context) {
  const url = 'https://neura-knights-api-prod.anomalygames.ai/api/package/open';
  const payload = {
    novalink_user_id: novaLinkUserId,
    package_type: packageType,
    package_collection: packageCollection
  };
  const config = getAxiosConfig(proxy, token, true);
  config.validateStatus = (status) => status >= 200 && status < 500;
  try {
    const response = await requestWithRetry('post', url, payload, config, 3, 2000, context);
    if (response.data.success) {
      return { success: true, cards: response.data.data?.cards || [] };
    } else {
      return { success: false, message: response.data.message || 'Failed to open pack' };
    }
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function autoOpenAllPacks(novaLinkUserId, token, proxy, context) {
  logger.info('Starting auto open packs...', { context });

  const packages = await fetchUserPackages(novaLinkUserId, token, proxy, context);

  if (!packages || packages.length === 0) {
    logger.info('No packs available to open', { context });
    return { opened: 0, totalCards: 0 };
  }

  let totalOpened = 0;
  let totalCards = 0;

  for (const pack of packages) {
    const packCount = pack.count || 0;
    const packType = pack.package_type || 'base';
    const packCollection = pack.package_collection || 'ACT_1_PACK';
    const packName = pack.name || 'Unknown Pack';

    if (packCount <= 0) continue;

    logger.info(`Opening ${packCount}x ${packName}...`, { context });

    for (let i = 0; i < packCount; i++) {
      const result = await openPack(novaLinkUserId, token, packType, packCollection, proxy, context);
      if (result.success) {
        totalOpened++;
        totalCards += result.cards.length;
      }
      await delay(1);
    }
    logger.info(`Opened ${packCount}x ${packName}`, { context });
  }

  logger.success(`Opened ${totalOpened} packs, received ${totalCards} cards!`, { context });
  return { opened: totalOpened, totalCards };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2CAPTCHA SOLVER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CaptchaSolver {
  constructor(apiKey = CAPTCHA_API_KEY) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://2captcha.com';
  }

  async solveTurnstile(siteUrl = SITE_URL, siteKey = TURNSTILE_SITEKEY) {
    try {
      logger.info('Sending Turnstile captcha to 2captcha...', 'CAPTCHA');

      const submitRes = await axios.post(`${this.baseUrl}/in.php`, null, {
        params: {
          key: this.apiKey,
          method: 'turnstile',
          sitekey: siteKey,
          pageurl: siteUrl,
          json: 1
        },
        timeout: 30000
      });

      if (submitRes.data.status !== 1) {
        throw new Error(`2captcha submit failed: ${submitRes.data.request}`);
      }

      const taskId = submitRes.data.request;
      logger.info(`Captcha task submitted: ${taskId}`, 'CAPTCHA');

      for (let i = 0; i < 40; i++) {
        await delayMs(3000);

        const resultRes = await axios.get(`${this.baseUrl}/res.php`, {
          params: {
            key: this.apiKey,
            action: 'get',
            id: taskId,
            json: 1
          },
          timeout: 15000
        });

        if (resultRes.data.status === 1) {
          logger.success('Captcha solved successfully!', 'CAPTCHA');
          return resultRes.data.request;
        }

        if (resultRes.data.request !== 'CAPCHA_NOT_READY') {
          throw new Error(`2captcha error: ${resultRes.data.request}`);
        }
      }

      throw new Error('Captcha solving timeout (120s)');
    } catch (error) {
      logger.error(`Captcha solve failed: ${error.message}`, 'CAPTCHA');
      return null;
    }
  }

  async solveRecaptchaV2(siteUrl, siteKey) {
    try {
      const submitRes = await axios.post(`${this.baseUrl}/in.php`, null, {
        params: {
          key: this.apiKey,
          method: 'userrecaptcha',
          googlekey: siteKey,
          pageurl: siteUrl,
          json: 1
        },
        timeout: 30000
      });

      if (submitRes.data.status !== 1) {
        throw new Error(`2captcha submit failed: ${submitRes.data.request}`);
      }

      const taskId = submitRes.data.request;

      for (let i = 0; i < 60; i++) {
        await delayMs(3000);
        const resultRes = await axios.get(`${this.baseUrl}/res.php`, {
          params: {
            key: this.apiKey,
            action: 'get',
            id: taskId,
            json: 1
          },
          timeout: 15000
        });

        if (resultRes.data.status === 1) {
          return resultRes.data.request;
        }
        if (resultRes.data.request !== 'CAPCHA_NOT_READY') {
          throw new Error(`2captcha error: ${resultRes.data.request}`);
        }
      }
      throw new Error('reCAPTCHA solving timeout');
    } catch (error) {
      logger.error(`reCAPTCHA solve failed: ${error.message}`, 'CAPTCHA');
      return null;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTLE API CLIENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BattleAPI {
  constructor(token, proxy = null) {
    this.token = token;
    this.proxy = proxy;
    this.captchaSolver = new CaptchaSolver();
    this.captchaToken = null;
    this.proxyAgent = null;

    if (proxy) {
      this._initProxy(proxy);
    }
  }

  _initProxy(proxy) {
    try {
      if (proxy.startsWith('http://') || proxy.startsWith('https://')) {
        this.proxyAgent = new HttpsProxyAgent(proxy);
      } else if (proxy.startsWith('socks4://') || proxy.startsWith('socks5://')) {
        this.proxyAgent = new SocksProxyAgent(proxy);
      }
    } catch (e) { /* ignore */ }
  }

  getHeaders(bearer = false) {
    const headers = {
      'accept': 'application/json, text/plain, */*',
      'accept-encoding': 'gzip, deflate, br, zstd',
      'accept-language': 'en-US,en;q=0.9,id;q=0.8',
      'content-type': 'application/json',
      'origin': 'https://www.neuraknights.gg',
      'referer': 'https://www.neuraknights.gg/',
      'sec-ch-ua': '"Not(A:Brand";v="8", "Chromium";v="144", "Google Chrome";v="144"',
      'sec-ch-ua-mobile': '?0',
      'sec-ch-ua-platform': '"Windows"',
      'sec-fetch-dest': 'empty',
      'sec-fetch-mode': 'cors',
      'sec-fetch-site': 'cross-site',
      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.0.0 Safari/537.36'
    };

    if (this.token) {
      headers['authorization'] = bearer ? `Bearer ${this.token}` : this.token;
    }

    if (this.captchaToken) {
      headers['cf-turnstile-response'] = this.captchaToken;
      headers['x-turnstile-token'] = this.captchaToken;
    }

    return headers;
  }

  async request(method, url, data = null, bearer = false, retries = 3) {
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const config = {
          headers: this.getHeaders(bearer),
          timeout: 60000,
          validateStatus: (status) => status < 600
        };

        if (this.proxyAgent) {
          config.httpsAgent = this.proxyAgent;
          config.proxy = false;
        }

        let response;
        if (method === 'GET') {
          response = await axios.get(url, config);
        } else {
          response = await axios.post(url, data, config);
        }

        if (response.status === 403 || response.status === 429) {
          logger.warn(`Got HTTP ${response.status} - possible captcha challenge`, 'API');
          if (attempt <= 2) {
            const captchaToken = await this.captchaSolver.solveTurnstile();
            if (captchaToken) {
              this.captchaToken = captchaToken;
              logger.success('Captcha solved, retrying request...', 'API');
              continue;
            }
          }
          return response;
        }

        if (response.status >= 500) {
          if (attempt < retries) {
            logger.warn(`Server error ${response.status}, retry ${attempt}/${retries}...`, 'API');
            await delayMs(2000 * attempt);
            continue;
          }
        }

        return response;
      } catch (error) {
        if (attempt < retries) {
          logger.warn(`Request error: ${error.message}, retry ${attempt}/${retries}...`, 'API');
          await delayMs(2000 * attempt);
          continue;
        }
        throw error;
      }
    }
  }

  // ---- Game API Methods ----

  async getProfile() {
    const res = await this.request('GET', `${NOVALINK_API}/profile`, null, true);
    if (res.data?.success) {
      return {
        novaLinkUserId: res.data.data.novaLinkUserId,
        email: res.data.data.authentications?.[0]?.email || 'N/A'
      };
    }
    throw new Error(`Failed to get profile: ${res.status}`);
  }

  async getGameState(novaLinkUserId) {
    const res = await this.request('GET', `${API_BASE}/state?novalink_user_id=${novaLinkUserId}`, null, true);
    if (res.data?.success) {
      return res.data.data;
    }
    return null;
  }

  async getHeroes(novaLinkUserId) {
    const res = await this.request('GET', `${API_BASE}/user/heroes?novalink_user_id=${novaLinkUserId}`, null, false);
    if (res.data?.success) {
      return res.data.data;
    }
    return [];
  }

  async startBattle(location) {
    const res = await this.request('POST', `${API_BASE}/game/battle/start`, { location }, false);
    return res.data;
  }

  async getBattleState() {
    const res = await this.request('GET', `${API_BASE}/game/battle`, null, false);
    return res.data;
  }

  async playCard(cardId) {
    const res = await this.request('POST', `${API_BASE}/game/battle/play`, { card_id: cardId }, false);
    return res.data;
  }

  async endTurn() {
    try {
      const res = await this.request('POST', `${API_BASE}/game/battle/end-turn`, {}, false, 1);
      return res?.data || null;
    } catch (e) {
      return null;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTLE STRATEGY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Card priority for playing order.
 * Strategy: buffs first, then defense, then attack last (benefits from buffs)
 * IMPORTANT: Necklace cards are PASSIVE-ONLY and must NEVER be played.
 * Playing Necklace causes a server-side NaN energy bug that corrupts the battle.
 */
function getCardPriority(cardId) {
  const id = cardId.toLowerCase();
  if (BANNED_CARD_TYPES.some(t => id.includes(t))) return 999;
  if (id.includes('hat')) return 1;
  if (id.includes('off-hand') || id.includes('off_hand')) return 2;
  if (id.includes('chest')) return 3;
  if (id.includes('weapon')) return 4;
  return 5;
}

function sortCardsByPriority(cards) {
  return [...cards]
    .filter(c => !BANNED_CARD_TYPES.some(t => c.toLowerCase().includes(t)))
    .sort((a, b) => getCardPriority(a) - getCardPriority(b));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SINGLE BATTLE RUNNER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function runSingleBattle(api, location, ctx = '') {
  const battleCtx = ctx ? `${ctx}|${location}` : location;
  const startTime = Date.now();

  // Step 1: Start the battle
  logger.battle(`Starting battle at ${location}...`, battleCtx);
  const startResult = await api.startBattle(location);

  if (!startResult?.success) {
    const msg = startResult?.message || JSON.stringify(startResult) || 'Unknown error';
    logger.warn(`Start battle response: ${msg}`, battleCtx);

    if (msg.includes('already') || msg.includes('active') || msg.includes('ongoing') || msg.includes('existing')) {
      logger.warn('Active battle detected, attempting to continue...', battleCtx);
      try {
        const checkActive = await api.getBattleState();
        if (checkActive?.success && checkActive?.data) {
          const activeLoc = checkActive.data.battle_location;
          if (activeLoc && activeLoc !== location && activeLoc !== 'Training Grounds') {
            logger.warn(`Active battle is for ${activeLoc}, not ${location}`, battleCtx);
            return { success: false, won: false, reason: 'wrong_map', activeMap: activeLoc };
          }
        }
      } catch (e) {
        // Can't verify, continue anyway
      }
    } else if (msg.includes('coin') || msg.includes('energy') || msg.includes('insufficient') || msg.includes('lives') || msg.includes('no lives') || msg.includes('out of')) {
      logger.error('No lives/energy for battle', battleCtx);
      return { success: false, won: false, reason: 'no_lives' };
    } else if (msg.includes('unlock') || msg.includes('locked') || msg.includes('not available') || msg.includes('cannot access') || msg.includes('level')) {
      logger.warn(`Map ${location} is locked`, battleCtx);
      return { success: false, won: false, reason: 'map_locked' };
    } else {
      logger.error(`Cannot start battle: ${msg}`, battleCtx);
      return { success: false, won: false, reason: msg };
    }
  } else if (startResult.data) {
    const d = startResult.data;
    logger.info(`Battle started! Hero HP: ${d.hero_hp}/${d.hero_max_hp} vs ${d.monster_type} HP: ${d.monster_hp}/${d.monster_max_hp}`, battleCtx);
  }

  // Step 2: Battle loop
  let battleOver = false;
  let won = false;
  let roundCount = 0;
  let lastMonsterHp = null;
  let lastHeroHp = null;
  let staleCount = 0;
  let consecutiveErrors = 0;
  let lastRound = 0;
  let battleXpGained = 0;
  let battleGoldGained = 0;

  while (!battleOver && roundCount < MAX_ROUNDS) {
    if (Date.now() - startTime > BATTLE_TIMEOUT_MS) {
      logger.warn('Battle timeout reached (3min)!', battleCtx);
      break;
    }

    roundCount++;

    let stateRes;
    try {
      stateRes = await api.getBattleState();
    } catch (e) {
      logger.warn(`State fetch error: ${e.message}`, battleCtx);
      consecutiveErrors++;
      if (consecutiveErrors >= 3) {
        logger.error('Too many consecutive errors, stopping battle', battleCtx);
        break;
      }
      await delayMs(ROUND_POLL_DELAY_MS);
      continue;
    }

    if (!stateRes?.success) {
      const msg = stateRes?.message || '';
      if (msg.includes('no active') || msg.includes('not found') || msg.includes('no battle')) {
        logger.info('No active battle found - battle may have ended', battleCtx);
        battleOver = true;
        break;
      }
      consecutiveErrors++;
      if (consecutiveErrors >= 3) {
        logger.error('Cannot get battle state after retries', battleCtx);
        break;
      }
      await delayMs(ROUND_POLL_DELAY_MS);
      continue;
    }

    consecutiveErrors = 0;
    const battleState = stateRes.data;

    if (!battleState || (!battleState.hero_hp && !battleState.monster_hp && battleState.monster_max_hp === 0)) {
      logger.info('Battle state is empty - battle already completed', battleCtx);
      battleOver = true;
      won = true;
      break;
    }

    if (battleState.hero_hp !== undefined && battleState.hero_hp <= 0) {
      logger.warn(`Battle lost! Hero HP: ${battleState.hero_hp}`, battleCtx);
      battleOver = true;
      won = false;
      break;
    }

    const monsterHp = battleState.monster_hp ?? battleState.monster_stats?.hp;
    if (monsterHp !== undefined && monsterHp <= 0) {
      logger.success('Battle won! Monster defeated!', battleCtx);
      battleOver = true;
      won = true;
      break;
    }

    if (battleState.battle_result || battleState.result || battleState.status === 'completed' || battleState.status === 'ended') {
      battleOver = true;
      won = (battleState.battle_result === 'win' || battleState.result === 'win' || battleState.won === true);
      logger.info(`Battle result: ${won ? 'WIN' : 'LOSS'}`, battleCtx);
      break;
    }

    const currentRound = battleState.current_round || 0;
    if (currentRound > 0 && currentRound === lastRound) {
      staleCount++;
      if (staleCount >= 10) {
        logger.warn('Battle stale - round not advancing, forcing end turn...', battleCtx);
        await api.endTurn();
        staleCount = 0;
        await delayMs(ROUND_POLL_DELAY_MS);
        continue;
      }
    } else {
      staleCount = 0;
    }
    lastRound = currentRound;
    lastMonsterHp = monsterHp;
    lastHeroHp = battleState.hero_hp;

    const roundNum = battleState.current_round || roundCount;
    logger.info(`--- Round ${roundNum} ---`, battleCtx);
    logger.info(`Hero HP: ${battleState.hero_hp}/${battleState.hero_max_hp} | Energy: ${battleState.hero_energy} | Block: ${battleState.hero_stats?.block || 0} | Str: ${battleState.hero_stats?.strength || 0}`, battleCtx);
    logger.info(`${battleState.monster_type || 'Monster'} HP: ${monsterHp}/${battleState.monster_max_hp} | Intent: ${battleState.monster_intent || '?'}`, battleCtx);

    if (battleState.current_turn_entity && battleState.current_turn_entity !== 'Player') {
      logger.info(`Waiting for ${battleState.current_turn_entity} turn...`, battleCtx);
      await delayMs(ROUND_POLL_DELAY_MS);
      continue;
    }

    const availableCards = battleState.availableCards || [];
    const currentRoundPlayed = battleState.currentRoundPlayedCards || [];

    if (availableCards.length === 0) {
      logger.info('No cards available, ending turn...', battleCtx);
      await api.endTurn();
      await delayMs(ROUND_POLL_DELAY_MS);
      continue;
    }

    const sortedCards = sortCardsByPriority(availableCards);
    logger.info(`Playable cards (${sortedCards.length}/${availableCards.length}): ${sortedCards.map(c => c.replace(/Hero-|Archer-|-Base|-Starter|-Common|-Rare|-Epic/g, '').replace(/-/g, ' ')).join(', ')}`, battleCtx);

    let cardsPlayedThisTurn = 0;

    for (const cardId of sortedCards) {
      if (battleOver) break;
      if (Date.now() - startTime > BATTLE_TIMEOUT_MS) break;

      const cardName = cardId.replace(/Hero-|Archer-|-Base|-Starter|-Common|-Rare|-Epic/g, '').replace(/-/g, ' ').trim();

      try {
        const playResult = await api.playCard(cardId);

        if (!playResult?.success) {
          const msg = playResult?.message || JSON.stringify(playResult) || '';
          const msgLower = msg.toLowerCase();

          if (msgLower.includes('energy') || msgLower.includes('insufficient') || msgLower.includes('not enough')) {
            break;
          }
          if (msgLower.includes('not your turn') || msgLower.includes('enemy') || msgLower.includes('monster')) {
            break;
          }
          if (msgLower.includes('over') || msgLower.includes('ended') || msgLower.includes('no active') || msgLower.includes('no battle')) {
            battleOver = true;
            break;
          }
          if (msgLower.includes('nan') || msgLower.includes('null')) {
            logger.warn(`  ${cardName}: server error, skipping card`, battleCtx);
            continue;
          }
          logger.warn(`  ${cardName} rejected: ${msg.substring(0, 80)}`, battleCtx);
          continue;
        }

        cardsPlayedThisTurn++;

        const battleResult = playResult.data?.battleResult;
        if (battleResult) {
          won = (battleResult.result === 'win');
          battleOver = true;
          battleXpGained = battleResult.xpGained || 0;
          battleGoldGained = battleResult.goldGained || 0;
          if (won) {
            logger.success(`  ${cardName} => KILLING BLOW! ${battleResult.monster} defeated!`, battleCtx);
            logger.success(`  Rewards: ${battleXpGained} XP, ${battleGoldGained} Gold`, battleCtx);
          } else {
            logger.warn(`  Battle ended: ${battleResult.result}`, battleCtx);
          }
          break;
        }

        const bs = playResult.data?.battleState || playResult.data;
        if (bs && bs.hero_hp !== undefined) {
          if (bs.hero_hp <= 0) {
            logger.warn(`  Hero died! HP: ${bs.hero_hp}`, battleCtx);
            battleOver = true;
            won = false;
            break;
          }

          const bsMonsterHp = bs.monster_hp ?? bs.monster_stats?.hp;
          if (bsMonsterHp !== undefined && bsMonsterHp <= 0) {
            logger.success(`  Monster defeated! HP: ${bsMonsterHp}`, battleCtx);
            battleOver = true;
            won = true;
            break;
          }

          lastMonsterHp = bsMonsterHp;
          lastHeroHp = bs.hero_hp;

          logger.info(`  ${cardName} => HP:${bs.hero_hp} E:${bs.hero_energy} Blk:${bs.hero_stats?.block || 0} | Monster HP:${bsMonsterHp}`, battleCtx);
        } else if (!playResult.data?.battleState && playResult.data?.availableCards?.length === 0) {
          battleOver = true;
          won = true;
          break;
        }

        await delayMs(CARD_PLAY_DELAY_MS);

      } catch (cardErr) {
        logger.error(`  Card play error: ${cardErr.message}`, battleCtx);
        break;
      }
    }

    // ALWAYS end turn after playing cards
    if (!battleOver) {
      const endResult = await api.endTurn();
      if (endResult?.success) {
        const es = endResult.data?.battleState || endResult.data;

        const endBattleResult = endResult.data?.battleResult;
        if (endBattleResult) {
          won = (endBattleResult.result === 'win');
          battleOver = true;
          battleXpGained = endBattleResult.xpGained || 0;
          battleGoldGained = endBattleResult.goldGained || 0;
          if (won) {
            logger.success(`  End turn => ${endBattleResult.monster} defeated! ${endBattleResult.xpGained} XP`, battleCtx);
          } else {
            logger.warn(`  End turn => Battle result: ${endBattleResult.result}`, battleCtx);
          }
        } else if (es && es.hero_hp !== undefined) {
          if (es.hero_hp <= 0) {
            logger.warn(`  Monster turn killed hero! HP: ${es.hero_hp}`, battleCtx);
            battleOver = true;
            won = false;
          } else if (es.monster_hp !== undefined && es.monster_hp <= 0) {
            logger.success('  Monster died during its turn!', battleCtx);
            battleOver = true;
            won = true;
          } else {
            lastMonsterHp = es.monster_hp;
            lastHeroHp = es.hero_hp;
            logger.info(`  End turn => Hero HP:${es.hero_hp} | Monster HP:${es.monster_hp} (Round ${es.current_round})`, battleCtx);
          }
        }
      } else {
        try {
          const checkState = await api.getBattleState();
          if (!checkState?.data?.hero_hp) {
            battleOver = true;
            won = true;
          }
        } catch (e) {
          battleOver = true;
        }
      }
      await delayMs(ROUND_POLL_DELAY_MS);
    }
  }

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  const timedOut = !battleOver && !won;

  if (won) {
    logger.success(`VICTORY at ${location} in ${roundCount} rounds (${elapsed}s)`, battleCtx);
  } else if (battleOver) {
    logger.warn(`DEFEAT at ${location} after ${roundCount} rounds (${elapsed}s)`, battleCtx);
  } else {
    logger.warn(`Battle at ${location} incomplete after ${roundCount} rounds (${elapsed}s)`, battleCtx);
  }

  return { success: true, won, rounds: roundCount, elapsed, xpGained: battleXpGained, goldGained: battleGoldGained, timedOut };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAP BATTLE ORCHESTRATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getAvailableMaps(gameState) {
  const allMaps = ['Forest', 'Bridge', 'Caves', 'Ghost Town', 'Mountain', 'Castle'];

  if (gameState?.dailyBattleHistory && gameState.dailyBattleHistory.length > 0) {
    const playedLocations = gameState.dailyBattleHistory.map(h => h.battle_location);
    const played = allMaps.filter(m => playedLocations.includes(m));
    const unplayed = allMaps.filter(m => !playedLocations.includes(m));
    return [...played, ...unplayed];
  }

  return allMaps;
}

function getBattleLives(gameState) {
  if (!gameState) return 0;
  return (gameState.daily_lives || 0) + (gameState.bonus_lives || 0);
}

/**
 * Main entry point - run battles on all unlocked maps
 * SMART MAP-COMPLETION LOGIC: ensures every map's daily battle quota is fully used.
 */
async function runAllMapBattles(token, context = '', headless = false, novaLinkUserId = null, proxy = null) {
  const ctx = context || 'Battle';
  const api = new BattleAPI(token, proxy);

  logger.info(chalk.bold.cyan('========================================'), ctx);
  logger.info(chalk.bold.cyan('   SMART BATTLE SYSTEM (Map Completion)'), ctx);
  logger.info(chalk.bold.cyan('========================================'), ctx);

  let totalBattles = 0;
  let totalWins = 0;
  let totalLosses = 0;

  const ALL_MAPS = ['Forest', 'Bridge', 'Caves', 'Ghost Town', 'Mountain', 'Castle'];

  // Per-map tracking
  const lockedMaps = new Set();
  const exhaustedMaps = new Set();
  const failedMaps = new Set();
  const mapLossCount = {};
  const mapWinCount = {};
  let mapBattleCount = {};
  let battlesPerMap = 3;

  try {
    // Step 1: Get user info
    if (!novaLinkUserId) {
      try {
        const profile = await api.getProfile();
        novaLinkUserId = profile.novaLinkUserId;
        logger.info(`User: ${profile.email} (${novaLinkUserId})`, ctx);
      } catch (e) {
        logger.error(`Failed to get profile: ${e.message}`, ctx);
        return { success: false, totalBattles: 0, wins: 0, losses: 0 };
      }
    }

    // Step 2: Get game state and analyze daily history
    let gameState = await api.getGameState(novaLinkUserId);
    if (!gameState) {
      logger.error('Failed to get game state', ctx);
      return { success: false, totalBattles: 0, wins: 0, losses: 0 };
    }

    battlesPerMap = gameState.daily_lives || 3;
    const bonusLives = gameState.bonus_lives || 0;
    logger.info(`Daily lives (quota per map): ${battlesPerMap}, Bonus lives: ${bonusLives}`, ctx);

    const history = gameState.dailyBattleHistory || [];
    mapBattleCount = {};
    for (const entry of history) {
      const loc = entry.battle_location;
      if (loc && loc !== 'Training Grounds') {
        mapBattleCount[loc] = (mapBattleCount[loc] || 0) + 1;
      }
    }

    // Check & handle active/stuck battle from previous session
    try {
      const activeBattle = await api.getBattleState();
      if (activeBattle?.success && activeBattle?.data?.monster_hp > 0 && activeBattle?.data?.hero_hp > 0) {
        const loc = activeBattle.data.battle_location || 'Unknown';

        if (loc === 'Training Grounds' || (activeBattle.data.monster_max_hp && activeBattle.data.monster_max_hp >= 5000)) {
          logger.warn(`Stuck Training Grounds battle detected (HP: ${activeBattle.data.monster_hp}), clearing...`, ctx);
          for (let i = 0; i < 3; i++) {
            await api.endTurn();
            await delayMs(500);
          }
        } else {
          logger.warn(`Active battle at ${loc}, completing first...`, ctx);
          const resumeResult = await runSingleBattle(api, loc, ctx);
          totalBattles++;
          if (resumeResult.won) {
            totalWins++;
            mapWinCount[loc] = (mapWinCount[loc] || 0) + 1;
          } else {
            totalLosses++;
          }
        }

        // Refresh state after handling active battle
        gameState = await api.getGameState(novaLinkUserId);
        if (gameState) {
          const freshHistory = gameState.dailyBattleHistory || [];
          mapBattleCount = {};
          for (const entry of freshHistory) {
            const loc2 = entry.battle_location;
            if (loc2 && loc2 !== 'Training Grounds') {
              mapBattleCount[loc2] = (mapBattleCount[loc2] || 0) + 1;
            }
          }
        }
      }
    } catch (e) {
      logger.warn(`Could not check active battle: ${e.message}`, ctx);
    }

    // Step 3: Get hero info
    try {
      const heroes = await api.getHeroes(novaLinkUserId);
      if (heroes && heroes.length > 0) {
        const activeHero = heroes.find(h => h.is_active) || heroes[0];
        logger.info(`Active hero: ${activeHero.class} (loadout: ${activeHero.loadout})`, ctx);
      }
    } catch (e) {
      logger.warn(`Could not fetch heroes: ${e.message}`, ctx);
    }

    // Step 4: Show initial per-map quota status
    logger.info(chalk.bold('--- Per-Map Quota Status ---'), ctx);
    for (const map of ALL_MAPS) {
      const done = mapBattleCount[map] || 0;
      const remaining = Math.max(0, battlesPerMap - done);
      if (done >= battlesPerMap) {
        exhaustedMaps.add(map);
        logger.info(chalk.green(`  [DONE] ${map}: ${done}/${battlesPerMap}`), ctx);
      } else if (done > 0) {
        logger.info(chalk.yellow(`  [${done}/${battlesPerMap}] ${map}: ${remaining} remaining`), ctx);
      } else {
        logger.info(`  [0/${battlesPerMap}] ${map}: not started`, ctx);
      }
    }

    const allDone = ALL_MAPS.every(m => (mapBattleCount[m] || 0) >= battlesPerMap);
    if (allDone) {
      logger.success('All map quotas already completed for today!', ctx);
    } else {
      logger.info(chalk.bold('Starting smart battle campaign...'), ctx);
    }

    // Step 5: SMART BATTLE LOOP
    let noLivesDetected = false;
    let consecutiveErrors = 0;

    while (!noLivesDetected && consecutiveErrors < 3 && totalBattles < MAX_TOTAL_BATTLES) {
      let nextMap = null;
      let lowestCount = Infinity;

      for (const map of ALL_MAPS) {
        if (lockedMaps.has(map) || exhaustedMaps.has(map) || failedMaps.has(map)) continue;
        const count = mapBattleCount[map] || 0;
        if (count < battlesPerMap && count < lowestCount) {
          lowestCount = count;
          nextMap = map;
        }
      }

      if (!nextMap) {
        break;
      }

      const done = mapBattleCount[nextMap] || 0;
      const remaining = battlesPerMap - done;

      logger.info(chalk.cyan(`===== Battle ${totalBattles + 1}: ${nextMap} [${done}/${battlesPerMap}] (${remaining} remaining) =====`), ctx);

      try {
        const result = await runSingleBattle(api, nextMap, ctx);

        if (result.reason === 'no_coins' || result.reason === 'no_lives') {
          logger.warn('Server says no more lives/energy!', ctx);
          noLivesDetected = true;
          break;
        }

        if (result.reason === 'map_locked') {
          lockedMaps.add(nextMap);
          logger.warn(`${nextMap} is LOCKED, skipping permanently`, ctx);
          consecutiveErrors = 0;
          continue;
        }

        if (result.reason === 'wrong_map') {
          const activeMap = result.activeMap;
          logger.warn(`Active battle belongs to ${activeMap}, completing it first...`, ctx);
          const resumeResult = await runSingleBattle(api, activeMap, ctx);
          totalBattles++;
          if (resumeResult.won) {
            totalWins++;
            mapWinCount[activeMap] = (mapWinCount[activeMap] || 0) + 1;
            mapBattleCount[activeMap] = (mapBattleCount[activeMap] || 0) + 1;
            failedMaps.delete(activeMap);
            mapLossCount[activeMap] = 0;
          } else if (!resumeResult.timedOut) {
            totalLosses++;
          }
          try {
            const refreshed = await api.getGameState(novaLinkUserId);
            if (refreshed) {
              gameState = refreshed;
              const freshHistory = refreshed.dailyBattleHistory || [];
              for (const map of ALL_MAPS) {
                mapBattleCount[map] = freshHistory.filter(h => h.battle_location === map).length;
                if (mapBattleCount[map] >= battlesPerMap && !exhaustedMaps.has(map)) {
                  exhaustedMaps.add(map);
                  logger.success(`[DONE] ${map} quota complete per server! (${mapBattleCount[map]}/${battlesPerMap})`, ctx);
                }
              }
            }
          } catch (e) { /* keep local counts */ }
          await delayMs(1500);
          consecutiveErrors = 0;
          continue;
        }

        if (result.won) {
          totalBattles++;
          totalWins++;
          consecutiveErrors = 0;
          mapLossCount[nextMap] = 0;
          mapWinCount[nextMap] = (mapWinCount[nextMap] || 0) + 1;

          mapBattleCount[nextMap] = (mapBattleCount[nextMap] || 0) + 1;

          if (mapBattleCount[nextMap] >= battlesPerMap) {
            exhaustedMaps.add(nextMap);
            logger.success(`[DONE] ${nextMap} quota complete! (${mapBattleCount[nextMap]}/${battlesPerMap})`, ctx);
          } else {
            logger.info(`${nextMap}: ${mapBattleCount[nextMap]}/${battlesPerMap} done`, ctx);
          }

          if (result.xpGained === 0 && result.goldGained === 0 && mapBattleCount[nextMap] > 0) {
            if (!exhaustedMaps.has(nextMap)) {
              exhaustedMaps.add(nextMap);
              logger.info(`${nextMap} gave 0 rewards - quota exhausted`, ctx);
            }
          }

        } else if (result.timedOut) {
          totalBattles++;
          logger.info(`${nextMap}: battle timed out but still active (will resume next attempt)`, ctx);
          consecutiveErrors = 0;

        } else {
          totalBattles++;
          totalLosses++;
          mapLossCount[nextMap] = (mapLossCount[nextMap] || 0) + 1;

          if (!result.success) {
            consecutiveErrors++;
          } else {
            consecutiveErrors = 0;
          }

          if (mapLossCount[nextMap] >= MAX_LOSSES_PER_MAP) {
            failedMaps.add(nextMap);
            logger.warn(`${nextMap}: ${mapLossCount[nextMap]} losses - hero too weak, skipping`, ctx);
          } else {
            logger.info(`${nextMap}: lost (attempt ${mapLossCount[nextMap]}/${MAX_LOSSES_PER_MAP}), will retry`, ctx);
          }
        }

        // Refresh game state
        try {
          const refreshed = await api.getGameState(novaLinkUserId);
          if (refreshed) {
            gameState = refreshed;
            const freshHistory = refreshed.dailyBattleHistory || [];
            for (const map of ALL_MAPS) {
              mapBattleCount[map] = freshHistory.filter(h => h.battle_location === map).length;
              if (mapBattleCount[map] >= battlesPerMap && !exhaustedMaps.has(map)) {
                exhaustedMaps.add(map);
                logger.success(`[DONE] ${map} quota complete per server! (${mapBattleCount[map]}/${battlesPerMap})`, ctx);
              }
            }
          }
        } catch (e) {
          // Keep local counts if refresh fails
        }

        await delayMs(1500);

      } catch (battleErr) {
        logger.error(`Battle error at ${nextMap}: ${battleErr.message}`, ctx);
        totalBattles++;
        totalLosses++;
        consecutiveErrors++;

        if (battleErr.response?.status === 403 || battleErr.message?.includes('403')) {
          logger.warn('Captcha challenge detected, solving...', ctx);
          const captchaToken = await api.captchaSolver.solveTurnstile();
          if (captchaToken) {
            api.captchaToken = captchaToken;
            logger.success('Captcha solved, continuing...', ctx);
            consecutiveErrors = 0;
          } else {
            logger.error('Captcha solve failed, stopping battles', ctx);
            break;
          }
        }

        if (consecutiveErrors >= 3) {
          logger.error('Too many consecutive errors, stopping', ctx);
          break;
        }

        await delayMs(2000);
      }
    }

  } catch (error) {
    logger.error(`Battle system error: ${error.message}`, ctx);
  }

  // ==================== CAMPAIGN SUMMARY ====================
  logger.info(chalk.bold.cyan('========================================'), ctx);
  logger.info(chalk.bold.cyan('      SMART BATTLE CAMPAIGN SUMMARY'), ctx);
  logger.info(chalk.bold.cyan('========================================'), ctx);
  logger.info(`Total Battles : ${totalBattles}`, ctx);
  logger.success(`Wins          : ${totalWins}`, ctx);
  if (totalLosses > 0) {
    logger.warn(`Losses        : ${totalLosses}`, ctx);
  } else {
    logger.info(`Losses        : ${totalLosses}`, ctx);
  }
  logger.info(`Win Rate      : ${totalBattles > 0 ? ((totalWins / totalBattles) * 100).toFixed(1) : 0}%`, ctx);

  logger.info(chalk.bold.cyan('--- Per-Map Results ---'), ctx);
  for (const map of ALL_MAPS) {
    const done = mapBattleCount[map] || 0;
    const wins = mapWinCount[map] || 0;
    const losses = mapLossCount[map] || 0;

    if (lockedMaps.has(map)) {
      logger.info(chalk.gray(`  [LOCKED]  ${map}`), ctx);
    } else if (exhaustedMaps.has(map)) {
      const extra = losses > 0 ? ` (${losses} loss${losses > 1 ? 'es' : ''})` : '';
      logger.success(`  [DONE]    ${map}: ${done}/${battlesPerMap}${extra}`, ctx);
    } else if (failedMaps.has(map)) {
      logger.warn(`  [FAILED]  ${map}: ${done}/${battlesPerMap} (${losses} losses - too hard)`, ctx);
    } else if (done > 0) {
      logger.info(chalk.yellow(`  [PARTIAL] ${map}: ${done}/${battlesPerMap}`), ctx);
    } else {
      logger.info(chalk.gray(`  [NONE]    ${map}: 0/${battlesPerMap}`), ctx);
    }
  }

  const completedCount = exhaustedMaps.size;
  const availableCount = ALL_MAPS.length - lockedMaps.size;
  const fullyDone = completedCount >= availableCount - failedMaps.size;

  if (fullyDone && failedMaps.size === 0) {
    logger.success(chalk.bold.green(`All ${completedCount} available map(s) fully completed!`), ctx);
  } else if (fullyDone) {
    logger.info(`${completedCount} map(s) completed, ${failedMaps.size} too hard, ${lockedMaps.size} locked`, ctx);
  } else {
    logger.warn(`${completedCount}/${availableCount} available map(s) completed`, ctx);
  }

  logger.info(chalk.bold.cyan('========================================'), ctx);

  return {
    success: true,
    totalBattles,
    wins: totalWins,
    losses: totalLosses,
    perMap: mapBattleCount,
    exhausted: [...exhaustedMaps],
    locked: [...lockedMaps],
    failed: [...failedMaps],
    verification: {
      battlesRun: totalBattles,
      winsCount: totalWins,
      lossCount: totalLosses
    }
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTLE WRAPPER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function autoBattle(novaLinkUserId, token, proxy, context, maxBattles = 10) {
  logger.info('Starting FULL API battle system...', { context });

  try {
    const result = await runAllMapBattles(token, context, false, novaLinkUserId, proxy);
    return {
      completed: result.totalBattles || 0,
      won: result.wins || 0
    };
  } catch (error) {
    logger.error(`Auto battle error: ${error.message}`, { context });
    return { completed: 0, won: 0 };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ACCOUNT PROCESSING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let globalAutoOpenPacks = false;
let globalAutoBattle = false;
let globalMaxBattles = 10;

async function processAccount(token, index, total, proxy) {
  const context = `Acc ${index + 1}`;
  const accountResult = {
    email: 'Unknown',
    points: '0',
    tasks: { total: 0, completed: 0, pending: 0 },
    taskDetails: [],
    packs: { opened: 0, cards: 0 },
    battles: { executed: 0, won: 0 },
    hero: null,
    tokenExpiry: null,
    nextPackClaim: null,
    status: 'Failed',
    error: null
  };

  // Update dashboard
  if (state.accounts[index]) {
    state.accounts[index].status = 'PROCESSING';
    state.accounts[index].info = 'Starting...';
  }
  renderTable();

  // Parse token expiry
  accountResult.tokenExpiry = parseTokenExpiry(token);
  if (accountResult.tokenExpiry?.expired) {
    logger.warn(`Token expired on ${accountResult.tokenExpiry.date.toLocaleString()}. Skipping.`, { context });
    if (state.accounts[index]) {
      state.accounts[index].status = 'EXPIRED';
      state.accounts[index].info = 'Token expired';
    }
    accountResult.status = 'Ignored (Expired)';
    return accountResult;
  }

  logger.info('Starting account processing', { context });

  try {
    const { email, novaLinkUserId } = await fetchProfile(token, proxy, context);

    if (!novaLinkUserId) {
      logger.warn('Failed to retrieve User ID. Token might be invalid. Skipping.', { context });
      if (state.accounts[index]) {
        state.accounts[index].status = 'FAILED';
        state.accounts[index].info = 'Invalid profile';
      }
      accountResult.status = 'Ignored (Invalid Profile)';
      return accountResult;
    }

    accountResult.email = email;

    // Get IP
    const ip = await getPublicIP(proxy, context);
    if (state.accounts[index]) {
      state.accounts[index].ip = ip;
    }
    logger.info(`Email: ${email} | IP: ${ip}`, { context });

    // Fetch game state for pack claim and gold
    let gameState = await fetchState(novaLinkUserId, token, proxy, context);

    if (gameState) {
      // Hero info
      accountResult.hero = {
        class: gameState.hero_class || gameState.class || 'Unknown',
        level: gameState.hero_level || gameState.level || 1,
        hp: gameState.hero_hp || gameState.hp || '?'
      };

      // Gold
      accountResult.points = (gameState.gold || gameState.coins || gameState.currency || 0).toString();

      // Next pack claim
      const nextClaim = gameState.next_package_claim_at;
      const currentTime = new Date();
      if (nextClaim === null || currentTime >= new Date(nextClaim)) {
        accountResult.nextPackClaim = 'Ready!';
      } else {
        const nextClaimDate = new Date(nextClaim);
        const diffMs = nextClaimDate - currentTime;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        accountResult.nextPackClaim = `${diffDays}d ${diffHours}h`;
      }
    }

    // Step 1: Claim daily packs if available
    logger.info('Checking for packs claim...', { context });
    if (gameState) {
      const nextClaim = gameState.next_package_claim_at;
      const currentTime = new Date();
      if (nextClaim === null || currentTime >= new Date(nextClaim)) {
        await claimPackage(novaLinkUserId, token, proxy, context);
      } else {
        const nextClaimDate = new Date(nextClaim);
        const diffMs = nextClaimDate - currentTime;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        logger.info(`Packs not ready. Cooldown: ${diffDays}d ${diffHours}h`, { context });
      }
    } else {
      logger.warn('Failed to fetch state, skipping pack claim', { context });
    }

    // Step 2: Auto Battle FIRST (before task claims)
    if (globalAutoBattle) {
      logger.info('Starting Auto Battle...', { context });
      if (state.accounts[index]) {
        state.accounts[index].info = 'Battling...';
      }
      const battleResult = await autoBattle(novaLinkUserId, token, proxy, context, globalMaxBattles);
      accountResult.battles = { executed: battleResult.completed, won: battleResult.won };
    }

    // Step 3: Auto Open Packs
    if (globalAutoOpenPacks) {
      if (state.accounts[index]) {
        state.accounts[index].info = 'Opening packs...';
      }
      const packResult = await autoOpenAllPacks(novaLinkUserId, token, proxy, context);
      accountResult.packs = packResult;
    }

    // Step 4: Claim tasks AFTER battles are done
    logger.info('Starting tasks processing...', { context });
    if (state.accounts[index]) {
      state.accounts[index].info = 'Processing tasks...';
    }

    const activeTasks = await fetchActiveTasks(token, proxy, context);
    accountResult.tasks.total = activeTasks.length;

    const tasksToComplete = activeTasks.filter(task => task.claimable === true && task.userQuest === null);
    const tasksToClaimReward = activeTasks.filter(task => {
      if (!task.claimable) return false;
      if (task.userQuest === null) return false;
      const isClaimed = task.userQuest?.claimed_at || task.userQuest?.is_claimed;
      return !isClaimed;
    });

    accountResult.tasks.pending = tasksToComplete.length + tasksToClaimReward.length;

    accountResult.taskDetails = activeTasks.map(task => {
      let taskStatus = 'pending';
      if (task.userQuest) {
        const isClaimed = task.userQuest?.claimed_at || task.userQuest?.is_claimed;
        taskStatus = isClaimed ? 'claimed' : 'claimable';
      } else if (task.claimable) {
        taskStatus = 'claimable';
      }
      return {
        id: task.id,
        title: task.title || 'Unknown Task',
        status: taskStatus,
        reward: task.reward || task.points || task.gold || null
      };
    });

    let completedCount = 0;

    // Complete tasks that haven't been started
    if (tasksToComplete.length > 0) {
      logger.info(`Completing ${tasksToComplete.length} pending task(s)...`, { context });

      for (const task of tasksToComplete) {
        try {
          const result = await completeTask(token, task.id, task.title || 'Unknown Task', proxy, context);
          if (result.success) {
            completedCount++;
          }
        } catch (error) {
          logger.error(`Error completing task ${task.id}: ${error.message}`, { context });
        }
        await delay(2);
      }
    }

    // Claim rewards for completed tasks
    if (tasksToClaimReward.length > 0) {
      logger.info(`Claiming rewards for ${tasksToClaimReward.length} completed task(s)...`, { context });

      for (const task of tasksToClaimReward) {
        try {
          const result = await completeTask(token, task.id, task.title || 'Unknown Task', proxy, context);
          if (result.success) {
            completedCount++;
          }
        } catch (error) {
          logger.error(`Error claiming task ${task.id}: ${error.message}`, { context });
        }
        await delay(2);
      }
    }

    accountResult.tasks.completed = completedCount;

    if (completedCount === 0 && tasksToComplete.length === 0 && tasksToClaimReward.length === 0) {
      logger.info('No tasks ready to complete or claim', { context });
    } else {
      logger.info(`Processed: ${completedCount} task(s) completed/claimed`, { context });
    }

    // Task summary
    const refreshedTasks = await fetchActiveTasks(token, proxy, context);
    const claimedCount = refreshedTasks.filter(t => t.userQuest?.claimed_at || t.userQuest?.is_claimed).length;
    logger.info(`Tasks: ${claimedCount}/${refreshedTasks.length} claimed`, { context });

    // Step 5: Get updated gold/points from state
    gameState = await fetchState(novaLinkUserId, token, proxy, context);
    const totalGold = await fetchUserGold(gameState, context);
    accountResult.points = totalGold;
    logger.info(`Gold: ${totalGold}`, { context });

    logger.success('Completed account processing', { context });

    // Update dashboard
    if (state.accounts[index]) {
      state.accounts[index].status = 'SUCCESS';
      state.accounts[index].lastRun = Date.now();
      state.accounts[index].info = `Gold:${totalGold} W:${accountResult.battles.won} T:${completedCount}`;
    }
    renderTable();

    accountResult.status = 'Success';
    return accountResult;

  } catch (error) {
    logger.error(`Error processing account: ${error.message}`, { context });
    if (state.accounts[index]) {
      state.accounts[index].status = 'FAILED';
      state.accounts[index].lastRun = Date.now();
      state.accounts[index].info = error.message.substring(0, 26);
    }
    accountResult.status = 'Failed';
    accountResult.error = error.message;
    return accountResult;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function initializeConfig() {
  logger.info('Auto-configuring settings...');
  globalAutoOpenPacks = true;
  logger.info('Auto open packs: enabled');
  globalAutoBattle = true;
  logger.info('Auto battle: enabled (Full API Mode)');
}

async function runCycle() {
  const accounts = await readAccounts();
  if (accounts.length === 0) {
    logger.error('No accounts found in accounts.json');
    return;
  }

  // Initialize dashboard state
  state.accounts = accounts.map((acc, i) => ({
    index: i + 1,
    id: `Acc ${i + 1}`,
    status: 'WAITING',
    nextRun: null,
    lastRun: null,
    info: '-',
    ip: '-',
    proxy: acc.proxy || null
  }));
  renderTable();

  const sessionResults = [];

  for (let i = 0; i < accounts.length; i++) {
    const account = accounts[i];
    const token = account.token;
    const proxy = account.proxy || null;

    try {
      const result = await processAccount(token, i, accounts.length, proxy);
      sessionResults.push(result);
    } catch (error) {
      logger.error(`Error processing account: ${error.message}`, { context: `Acc ${i + 1}` });
      if (state.accounts[i]) {
        state.accounts[i].status = 'FAILED';
        state.accounts[i].info = error.message.substring(0, 26);
      }
      sessionResults.push({
        email: 'Unknown',
        points: '0',
        tasks: { total: 0, completed: 0, pending: 0 },
        packs: { opened: 0, cards: 0 },
        battles: { executed: 0, won: 0 },
        status: 'Failed',
        error: error.message
      });
    }
    await delay(5);
  }

  printSessionSummary(sessionResults);
  renderTable();
}

async function run() {
  renderTable();
  await initializeConfig();

  while (true) {
    try {
      await runCycle();
      await waitUntilScheduledTime(SCHEDULED_HOUR, SCHEDULED_MINUTE);
    } catch (error) {
      logger.error(`Cycle error: ${error.message}`);
      await waitUntilScheduledTime(SCHEDULED_HOUR, SCHEDULED_MINUTE);
    }
  }
}

run().catch(error => logger.error(`Fatal error: ${error.message}`));
